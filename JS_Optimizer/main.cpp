#include "config.h" // generated by CMake, contains #define SOLUTION_DIR ...

#include "Problem.h"
#include "Task.h"
#include "Optimizer.h"
#include "Solution.h"
#include "Utility.h"

#include "loguru.hpp"

#include <iostream>


/*
* helper functions
*/
namespace JSOptimzer {

	void test() {
		std::cout << "test" << std::endl;;
	}

}


int main() {
	using namespace JSOptimzer;
	loguru::add_file("logs/latest.log", loguru::Truncate, loguru::Verbosity_INFO);
	loguru::add_file("logs/error.log", loguru::Truncate, loguru::Verbosity_ERROR);
	LOG_F(INFO, "Started Execution");
	
	std::string VSSolPath = std::string(SOLUTION_DIR);
	std::string problemsPath = VSSolPath + "/JobShopProblems/";
	std::string solutionsPath = VSSolPath + "/JobShopSolutions/";
	std::string visOutPath = VSSolPath + "/JobShopSolutions/visualizations/";
	std::string pythonPath = VSSolPath + "/pythonScripts/";

	Problem p_sb(problemsPath, "small_basic.txt");

	Solution s_sb(solutionsPath, "small_basic_SampleSol_testing_improved.txt");
	
	long solTime = s_sb.getCompletetionTime();

	s_sb.saveToFile(solutionsPath, "small_basic_SampleSol_saved.txt");

	if (s_sb.validateSolution(p_sb)) {
		LOG_F(INFO, "p_sb is solved by s_sb");
	}
	else {
		LOG_F(INFO, "p_sb is *not* solved by s_sb");
	}
	
	std::cout << "Completion time of solution is: " << solTime;
	std::cout << ", the lower bound is:" << p_sb.getBounds().getLowerBound() << std::endl;
	std::cout << "mbound " << p_sb.getBounds().MachineLowerBound << ", tbound " << p_sb.getBounds().TaskLowerBound << std::endl;

	std::cout << p_sb;
	//std::cout << std::endl;
	std::cout << s_sb;


	LOG_F(INFO, "Creating visualization...");

	Utility::visualize(solutionsPath, "name", visOutPath);


	LOG_F(INFO, "Finished Execution");
	return 0;
}

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>JS Optimization Doc</title>
<link rel="stylesheet" href="resources/styleguide.css">
<link rel="shortcut icon" href="resources/favicon.ico">
<script src="resources/styleguide.js"></script>
</head>
<body onload="initStyleGuide();">

<div class="flex-container">
<div class="left-border"></div>
<div id="content">
<h1>JS Optimization Documentation</h1>

<h2 id="Background" class="ignoreLink">Background</h2>

<p>Originally this repository was part of a project for the course "Optimization
  Methods for Engineers" (227-0707-00L) at ETH Zurich.<br> The goal of the project was to
  implement an optimizer for a chosen problem and write a report about the results.</p>

<h3 id="credit" class="ignoreLink">Documentation Credit</h3>

<p>This documentation uses styles and JavaScript taken from the
  <a href="https://github.com/google/styleguide"> Google Style Guides</a>
  (with minor changes).</p>

<!--Create the Table of Contents -->
<div class="horizontal_toc" id="tocDiv"></div>

<h2 id="project_goal">Project Goal</h2>
<p>This repository implements multiple optimizers for the
  <a href="https://en.wikipedia.org/wiki/Job-shop_scheduling">Job Shop scheduling</a>
  problem. Among the many variations of the problem the following definition is used:<p>
<p>An instances of the Job Shop scheduling problem consists of N Jobs that need to be
  scheduled on M machines. Each Job in turn consist of Tasks that have
  a processing order. Each of the J<sub>n</sub> Tasks of Job n has their own processing
  time and machine requirement.<br> A machine can only process a single Task at a time and
  processing is not preemptable.</p>
<p>For a rigorous description please consult this
  <a href="resources/assets/ProblemDefinition-ReportExcerpt.pdf">excerpt</a>
  from the report, which gives the mathematical problem definition.</p>
<p>Additionally the repository contains infrastructure to deal with:
  <ul><li>Problems,</li><li>Solutions,</li><li>and Search Space Representations.</li></ul>
  This allows many different optimizers with varying stepping procedures to be implemented
  easily and quickly.</p>

<h2 id="components">Components Overview</h2>

<p>The JS_Optimization Visual Studio Solution contains three projects. They are two
  libraries (JS_Lib and Loguru) and the entry point JS_Optimizer.</p>
<p>The following subsections briefly describe each project.</p>

<h3 id="js_optimizer">JS_Optimizer</h3>

<p>This project is designated as the executable for the CMake build and contains the
  main.cpp file.</p>
<p>The JS_Optimizer project servers as a minimal wrapper for the JS_Lib functionality
  and enables the creation of actual executables that perform optimization.<br>
  There is no proper user interface, the configuration of the optimizations is done by
  changing the code in the main.cpp file.</p>
<p>Besides the main function it contains the following functions:</p>
<ul>
  <li>a small sanity test function to verify that the project is setup correctly </li>
  <li>a bigger test that exercises all the functionality</li>
  <li>the 'runOptimizer' template function that shows how to create a Problem and
    Optimizer and then run the Optimizer. It also shows how to validate and store the
    Solution. The configuration needs to be done manually.</li>
  <li>the 'evaluateOptimizers' function that uses the StatsCollector utility class to run
    and log an Optimizer on problems in bulk.</li>
</ul>
<p>These functions and the comments in the main function should provide ample usage
  examples.</p>
<p>Some global variables that define the default absolute file paths are automatically
  setup with the CMake build. The absolute paths are expected by the Problem and Solution
  constructors.</p>

<h3 id="optimizer">JS_Lib</h3>

<p>This project is the core functionality. All the optimization code is completely
  contained inside the JS_Lib project.<br> To use JS_Lib include
  'JS_Optimization/JS_Lib/include/JS_Lib.h' in your project.</p>
<p>The code in JS_Lib can be grouped like this: problem_base, optimizer_base, optimizers
  and utility.</p>

<figure style ="max-width:800px">
  <img src="resources/assets/JS_Lib_UML.svg" alt="UML Diagram of JS_Lib">
  <figcaption>For clarity purposes not all associations are depicted, the two most obvious
    omissions are: the links from problem_base to the optimizers, and the links from the
    representations to the Solution class which is sub-classed in order to provide a
    constructor for Solutions</figcaption>
</figure>

<p>The 'problem_base' enables the creation, saving and loading of Problem instances. It
  also defines the general Solution object that all optimizers ultimately generate. The
  Solution class enables saving and loading of solutions and it also offers a solution
  validation utility.</p>
<p>The 'optimizer_base' code defines 'Optimizer.h', a base class for all optimizers.
  It also defines multiple possible representations on which an optimizer can operate.<br>
  The representations provide initialisation and basic manipulation of the representation
  as well as the creation of Solutions from the internal state.</p>
<p>Optimizers choose a representation and then define the initialisation, iteration and
  termination functions for the optimization process of the optimizer. Currently there are
  four different optimizers implemented.</p>
<p>Both new representations and optimizers can be added.<br>
  All optimizers should subclass/extend the Optimizer class defined in Optimizer.h.
  However using a representation is not required.</p>
<p>For more details see the <a href="#structure">JS Lib</a> section below.</p>
<p>All the different header files are directly accessible without the need to specify
  the path through the subfolders in the source tree. Since this is a small project I
  choose convenience over the more principled approach. If many additional files are to be
  added, I would recommended using subfolders inside the current folders. With the
  current CMake configuration, these folders should not be added to the include path
  automatically. This should limit the issues that arise from the extended include path.
</p>

<h3 id="loguru">Loguru</h3>

<p>The logging needs of the project are covered with "Loguru" by emilk.
  See his <a href="https://github.com/emilk/loguru"> GitHub repository</a>.</p>
<p>Version 2.1.0 cloned in April 2023 is included/setup in this repository. Refer to it's 
  <a href="../loguru/index.html">documentation</a> and the README in the
  JS_Optimization/loguru/ folder for usage details.</p>
<p>To use it simply include the 'loguru.hpp' header. CMake is setup such that direct
  inclusion without any path prefix is possible.</p>

<h3 id="dependencies">Dependencies</h3>

<p>The project uses CMake to setup the Visual Studio solution, hence it requires both
  CMake and Visual Studio. C++20 is required to compile the source code.</p>
<p>There are a couple optional helper scripts that require a Python installation
  (see <a href="#PythonScripts">Python Helper Scripts</a>).<br> Some of the scripts use
  <a href="https://developers.google.com/optimization">Google OR-Tools</a>.
  They require the installation of the 'ortools' package, see the
  <a href="https://developers.google.com/optimization/install/python">Installation Guide</a>
  from the Google OR-Tools website.</p>

<h2 id="js_lib">JS_Lib</h2>

<p>The following sections will cover the JS_Lib components in more detail. But this
  documentation does not aim to provide a User Manual for the code. The usage of the
  code should be evident from the names and the comments.</p>
<p>Instead the conceptual ideas behind the components will be explained. Additionally
  what functionality each component offers will be covered.</p>

<h3 id="js_problem">Problems</h3>

<p>Problem objects can be created from text files. The constructor requires the path and
  name of a file (including the file extension) that contains a valid problem description.
  There are two separate formats for the layout inside the text files, see
  <a href="#problem_format">Problem Description</a>, which format is used must also be
  supplied to the constructor.</p>
<p>A problem instance is immutable but provides a number of constant getter functions to
  inspect it's contents.</p>
<p>An invalid file or file content will abort execution.</p>
<p>Each Problem also has a Problem::Bounds instance associated with it. The Bounds object
  provides some absolute lower bounds on the completion time of the Problem.</p>
<p>The Problem class offers:</p>
<ul>
  <li>Loading of Problem instances from files in both file formats (using absolute paths).
  </li>
  <li>Creation of Problem instances from a given Solution.</li>
  <li>Saving of Problem instances to a file (with a format selection).</li>
  <li>Accessor methods to inspect a Problem.</li>
  <li>Basic timing bounds information about the Problem with the Problem::Bounds
    class.</li>
</ul>
<p>See Problem.h for the details.</p>
<p>Problems should be in saved in the 'JS_Optimization/JobShopProblems/' folder. The
  'JS_Optimization/JobShopProblems/Instances' should not be renamed, as</p>

<h3 id="js_solution">Solutions</h3>

<p>Solution instances usually get created by Optimizers. Typically the Representation the
  Optimizer uses implements a nested class that extends Solution and provides a
  constructor for Solutions.</p>
<p>Solutions are immutable. They are shared between the user code and
  the Optimizer itself. This is done safely with std::shared_ptr.</p>
<p>Solutions have their own file format (see
  <a href="#solution_format">Solution Description</a>).
  This format contains quite a lot of redundancy, this is used for faster and more
  thorough integrity checking and prevents the validation from inferring incorrect
  parameters.</p>
<p>Since the Solution class contains redundancy and is immutable it should not be used to
  store the internal solution state of optimizers. Instead a SolutionConstructor that
  subclasses Solution should be implemented. SolutionConstructor then converts the
  internal solution state to a canonical Solution. Since the internal solution state
  should only change between Search Space Representation and not between Optimizers on the
  same Representation, each one should supply the SolutionConstructor.</p>
<p>The Solution class offers:</p>
<ul>
  <li>Loading of Solutions from files (using absolute paths).</li>
  <li>Saving of Solutions to files (and by extension Visualization with the
    <a href="#createGantt">Python scripts</a>), using absolute paths.</li>
  <li>Accessor methods to inspect basic properties like the makespan, task count, etc.</li>
  <li>The Solution validation to check if a Solution is valid with respect to
    a given Problem instance.</li>
  <li>A view of the Tasks in Problem order</li>
</ul>
<p>See Solution.h for the details.</p>

<h3 id="js_optimizer_base">Optimizer Base</h3>

<p>Optimizer_base contains Optimizer.h which is the base class for all optimizers. Having
  a base class allows easy polymorphism and gives all optimizers a unified interface.</p>
<p>The other classes in 'JS_Optimization/JS_Lib/optimizer_base/' implement Search Space
  Representations. They subclass the Optimizer base class.</p>

<h4 id="js_optimizer_h">Optimizer.h</h4>

<p> Optimizer.h is an
  <a href="https://en.cppreference.com/w/cpp/language/abstract_class">Abstract Class</a>
  and defines some pure virtual functions, that need to be implemented by
  each optimizer. They are:<ul>
    <li><pre style="max-width: 150px; margin-left: 0;">void Initialize()</pre>
      <p style="text-indent: 25px;">initializes an optimization run</p></li>
    <li><pre style="max-width: 125px;margin-left: 0;">void Iterate()</pre>
      <p style="text-indent: 25px;">performs an optimization iteration</p></li>
    <li><pre style="max-width: 255px;margin-left: 0;">bool CheckTermination() const</pre>
      <p style="text-indent: 25px;">returns true if the termination criteria are
        reached</p></li>
    <li><pre style="max-width:380px;margin-left:0;"
      >std::shared_ptr&ltSolution&gt getBestSolution()</pre>
      <p style="text-indent: 25px;">get current best solution, sharing ownership</p></li>
    <li><pre style="max-width: 320px;margin-left: 0;"
      >std::string getOptimizerName() const</pre>
      <p style="text-indent: 25px;">allows easy identification if used with polymorphism
        </p></li></ul>
  The <a href="#js_optimizer_base_reps">Representations</a> do not implement these as they
  are intended to function as an intermediate. Instead they provide common functionality
  for a specific internal optimization structure.</p>
<p>Optimizer.h also contains a 'Run' function with a default implementation that can be
  overridden.</p>
<p>Typically an optimizer subclasses an Representation. It provides implementations for
  the functions mentioned above and uses the utilities the Representation provides.</p>
<p>The Representations that are provided in JS_Lib are described in their own sections
  below.</p>
<p>Optimizer Base also defines the <b>Termination Criteria</b> struct with the three
  different criteria: total iterations, restart count and a percentage relative to the
  lower bound. The 'CheckTermination()' should use this. Since the concept of an iteration
  may vary for different optimizers there is no default implementation for it.</p>

<h3 id="js_optimizer_base_reps">Search Space Representations</h3>
<p>The Representations are part of Optimizer_base. All of them subclass
  <a href="#js_optimizer_h">Optimizer.h</a>. But they do not implement the pure virtual
  functions of Optimizer.h since they are intended to function as support for the actual
  Optimizers.</p>
<p>The following sections will discuss all the Representations.</p><p><b>Index</b>
  <ul style="list-style: none;"><li><a href="#js_optimizer_machine_order_rep">Machine Order Representation</a></li>
    <li><a href="#js_optimizer_global_order_rep">Global Order Representation</a></li>
    <li><a href="#js_optimizer_graph_rep">Graph Representation</a></li></ul>
</p>

<h4 id="js_optimizer_machine_order_rep">Machine Order representation</h4>

<p>This Search Space Representation is straight forward. All Tasks are grouped per machine
  and placed in multisets. Then Tasks are pulled from a set to build the precedence order
  for the machine the set corresponds to.</p>

<figure style ="max-width:500px">
  <img src="resources/assets/Machine_Seq.svg"
    alt="Visualization of Machine Order Rep">
    <figcaption>Machine Sequences: underlying search structure</figcaption>
</figure>

<p>The schedule uses indirection to prevent a Task from Job x getting scheduled
  before another Task from Job x on the Machine that has a lower index. Meaning that the
  Set of Tasks is actually represented as a multiset of Job ids. The clique has an ordered
  list of task ids for each job. By tracking how far along the list each Job is, it is
  guaranteed that each Machine has an internal precedence order that is valid.</p>
<p>This only covers half the conflicts that may occur. The solution may still be unfeasible
  due to deadlocks across multiple machines. This is the major downside to this
  representation. It is very difficult to find and resolve these conflicts in this
  representation. The solution constructor will return uninitialized solutions should the
  current state be invalid. In that case the Solution will have a 'makespan_' of -1 and the
  'initialized_' bool will be false.</p>
<p>Each Machine has an instance of the MachineClique class which provides some getters
  and the current schedule for the machine. The schedule can be retrieved with the
  'getMachineOrder()'. It's contents should remain the same, only the order may be
  modified, else the Solution will be invalid with respect to the Problem.</p>

<p>The representation builds the machine cliques and mappings. The initial state is the
  sequential Solution obtain by scheduling the Jobs in ascending order. It also provides
  a Solution Constructor that builds the Solution from the current state the cliques
  contain.</p>
<p>The specific optimizer only needs to decide how elements are reordered in the cliques.</p>

<h4 id="js_optimizer_global_order_rep">Global Order representation</h4>

<p>Like the name suggests, this Search Space Representation uses a global ordering. The
  core of the Representation is a list that contains each Job Task-count times. This
  indirection functions similarly to the Machine Order and is used to prevent deadlocks
  from occurring.</p>

<figure style ="max-width:600px">
  <img src="resources/assets/Total_Order.svg" 
    alt="Visualization of Total Order Rep">
    <figcaption>Total Order: underlying search structure</figcaption>
</figure>

<p>The Index Lookup informs us how far along the list in the Lookup Table we are. This
  ensures each Job is conflict free. The global order intrinsically prevents conflicts
  across different Machines.</p>
<p>For these reasons the Global Task Order representation is only able to represent valid
  solutions. It can also still represent all possible solutions. The trade off is that
  this Representation increases the size of the Search Space significantly. The reason
  being that the number of permutations of the Total Order list is significantly larger
  than the combined number of permutations of all the individual Machines.</p>
<p>In practice this is an acceptable trade off. The two main reasons for this are:
  <ul><li>the original search space is already too large to be searched by brute force</li>
  <li>the number of invalid solutions is far larger than the number of valid solutions</li>
</ul>In short: the benefit of the restriction to valid solutions outweighs the downside of
the larger search space.</p>
<p>The Representation implements a constructor that creates an initial Total Order,
  representing the sequential solution. It also provides the SolutionConstructor that
  builds the Solution corresponding to the current Total Order.</p>
<p>The representation does not provide any utilities to provide information about bottlenecks
  in the schedule. An optimizer requiring such information has to implement this themselves.
  This is not provided for efficiency reasons, as the optimizer needs to decide very
  specifically what information it requires. Since the Representation loses a lot of
  information and it is expensive to recompute it.</p>

<h4 id="js_optimizer_graph_rep">Graph representation</h4>

<p>The Disjunctive Graph Representation is well known in literature. It is rather complex
  but makes a lot of information easily accessible. It also enables targeted manipulation
  of the current schedule.</p>
<p>Each vertex in the graph represents a Task. There are two kinds of edges. The
  R<sub>p</sub> relation contains edges that capture the immutable constraints of the
  problem instance (i.e. the Task processing order), also called the conjunctive arcs. The
  machine cliques are the mutable edges that an optimizer can change, also called the
  disjunctive arcs. They represent the actual schedule.</p>
<p>This is the initial state of the representation:</p>

<figure style="max-width:500px">
  <img src="resources/assets/Graph_Rep.svg"
    alt="Visualization of Graph Rep components">
    <figcaption>Disjunctive Graph: initial state of the underlying search structure
    </figcaption>
</figure>

<p>The machine cliques are groups of nodes that are connected by a complete graph of
  bidirectional edges (colour coded in the figure). They represent Tasks that need to be
  processed on the same Machine. For example the Tasks represented by vertices
  T<sub>10</sub>, T<sub>01</sub> and T<sub>21</sub> are one machine clique.</p>
<p> To create a schedule all the bidirectional edges need to be directed. The directed
  edges then define a schedule for the machine they belong to. The schedule is valid if
  and only if the complete graph containing both the Machine Clique edges and
  R<sub>p</sub> edges is acyclic.</p>
<p>GraphRep initializes all the immutable edges in the graph but leaves it up to the
  optimizer to insert the mutable edges (usually done with DacExtender). The cliques_
  member contains a list for each Machine that holds all the vertex ids that belong to
  the clique.</p>

<p>The GraphRep.h class provides a number of helpers to achieve this. The main ones are:</p>
<ul><li>PathsInfo</li>
  <li>DacExtender</li>
  <li>other helper functions</li>
<li>Solution Constructor</li></ul>
<p>Each PathsInfo instances are tightly coupled with a single GraphRep instance. PathsInfo
  calculates the Critical Path of the current graph/schedule. It does this with the
  <a href="https://en.wikipedia.org/wiki/Critical_path_method">critical path method</a>
  (CPM). A notable by-product of CPM is the current makespan of the graph. The main output
  of the CPM is the list of vertices on the critical path, but the concrete timings are
  available for all vertices.</p>
<p>DacExtender is a dynamic topological sorter. It takes an acyclic graph as input and then
  provides the 'InsertEdge()' function which takes two vertices as arguments and returns a
  directed edge that maintains the acyclic property of the graph. DacExtender performs
  deterministic insertion of new edges. But by randomizing the insertion order, the result
  can be randomized. This enables deterministic time random generation of initial DAC's
  that an optimizer can iterate on (i.e. random restarts).</p>
<p>There are a few helper functions to facilitate the changing of the internal graph, see
  GraphRep.h. They include a reachability and a cycle checker.</p>
<p>The SolutionConstructor simply creates a Solution from the internal state.</p>
<p>It also has mappings from vertices to Tasks and a separate mapping to the duration of
  the Task directly to avoid a double lookup.</p>

<h5 id="js_graphrep_subclassing">Sub-classing GraphRep</h5>

<p><b style="font-size: 11pt;">NOTE:</b></p>
<ul>
<li>If an optimizer <b>manually</b> changes the graph, it must set the 'modified_flag'
  bool member. If this is not done correctly PathsInfo will perform <b>no-ops</b> when
  update is called.</li>
<li>Two additional special vertices are introduced when a problem is loaded. A source
  (id:0) and a sink vertex (id:vertex_count_-1).</li>
<li>GraphRep uses unified successor and predecessor lists. Positive values encode
  successors and negative values predecessors. Additionally the immutable R<sub>p</sub>
  edges are separated from the mutable Machine Clique edges. This is done by adding an
  offset of vertex_count_ to the Machine Clique edges before any other operations.
  Combined this means for each vertex all neighbours can be found by iterating over
  graph_[vertex_id] and they can easily be filtered for predecessor, successor and
  mutability.</li>
</ul>

<h3 id="js_optimizers">Optimizers</h3>

<p>All Optimizer's subclass one of the optimizer_base classes. The different Representation
  classes implement some common functionality that a given search space representation
  may need. See their header files in JS_Lib/optimizer_base/ or the
  <a href="#js_optimizer_base">Optimizer Base</a> section of the documentation.</p>
<p>The optimizers themselves are not meant to be sub-classed.</p>
<p>All optimizers should subclass <a href="#js_optimizer_h">Optimizer.h</a>. Either
  directly or indirectly through a representation. And consequently they must implement
  the pure virtual functions Optimizer.h defines (<a href="#js_optimizer_h">listed
  here</a>).</p>
<p>The following sections will briefly describe the Optimizers that are already
  implemented.</p>

<h4 id="RandomSearchOpti">RandomSearch Optimizer</h4>

<p>This is a classic 'Random search' optimizer on the
  <a href="#js_optimizer_global_order_rep">Total Order Representation</a>.</p>
<p>It simply randomly shuffles the list containing the total order.</p>

<h4 id="RandomSearchMachOpti">RandomSearchMachine Optimizer</h4>

<p>This is a classic 'Random search' optimizer on the
  <a href="#js_optimizer_machine_order_rep">Machine Order Representation</a>.</p>
<p>It randomly shuffles the list with the ordering of each machine.</p>

<h4 id="RandomSwapOpti">RandomSwap Optimizer</h4>

<p>This is a 'Simulated Annealing' optimizer on the
    <a href="#js_optimizer_global_order_rep">Total Order Representation</a>.</p>
<p>It has all the typical components of a Simulated Annealing optimizer:
  <ul><li>a temperature that starts high and decreases with time</li>
  <li>making more changes per iteration if the temperature is higher</li>
  <li>a chance to accept worse Solutions that decreases as the Temperature decreases</li>
  <li>early random restarts if no progress is made for a number of iterations</li></ul>
</p>
<p>This optimizer uses a simple neighbourhood definition. Two solutions are direct
  neighbours if the schedule of one can be transformed into the other by performing a
  single swap of two consecutive elements in the total order list.</p>

<h4 id="ShftingBottleneckOpti">ShiftingBottleneck Optimizer</h4>

<p>This is a 'Simulated Annealing' optimizer on the
  <a href="#js_optimizer_graph_rep">Graph Representation</a>.</p>
<p>It has all the typical components of a Simulated Annealing optimizer:
  <ul><li>a temperature that starts high and decreases with time</li>
  <li>making more changes per iteration if the temperature is higher</li>
  <li>a chance to accept worse Solutions that decreases as the Temperature decreases</li>
  <li>early random restarts if no progress is made for a number of iterations</li></ul>
</p>
<p>This optimizer uses a number of heuristics to preselect swaps to alter the critical
  path of the graph. The choice of which swaps to perform is randomized. The number of swaps
  is determined by the temperature. See this
  <a href="resources/assets/EdgeSelectionHeuristics-ReportExcerpt.pdf">excerpt</a>
  of the report for a more detailed description of the heuristics.</p>

<h4 id="OptiPerformance">Performance Overview</h4>

<p>ShiftingBottleneck is the best among the implemented optimizers. It is also by far the
  slowest. It can find decent solutions with 2000 iterations. With the release build this
  should not take more than a couple minutes on decent hardware, even for the largest
  problems in the Instance folder. But it tends to bottleneck itself due to the implemented
  heuristics stalling in local optima. Because of this increasing the iteration count is
  usually not beneficial. Instead using more seeds and doing more runs with them is the
  better option to find better solutions.</p>
<p>RandomSwap and RandomSearch are essentially equivalent. They use the same Representation
  and although RandomSwap uses a different approach it relies on a neighbourhood definition
  that does not contain useful information. Consequently its behaviour is equivalent to
  the random shuffling RandomSearch does. These two Optimizers are very fast and given
  enough time could find the optimum. However the search space is many times too large for
  even a supercomputer to evaluate a decent percentage of the search space. For a low
  number of iterations, say under 10'000, ShiftingBottleneck should outperform these two
  consistently.</p>
<p>RandomSearchMachine is basically useless. It usually fails to find valid solutions at
  all. It only has a chance for very small problems. The reason being that the cross
  machine conflicts are far too common, making a vast majority of the schedules invalid.
</p>

<h3 id="js_utility">Utility</h3>

<p>Most of the utility code is not helpful when implementing Optimizers. But a couple
  functions might be nice, they are in:</p>
<ul><li>Utility.h</li><li>Heap.h</li></ul>
<p>Utility.h has remove_at() and randomPullUniqueFromRange(), which may be useful to
  access a container like a vector. The other functions are unlikely to be useful when
  implementing optimizers.</p>
  <p>The Heap class is a wrapper around the std::make_heap and friends of &ltalgorithm&gt
    and can be both a Max or a Min heap based on the comparator.
    The original intent was to store multiple solutions in a max heap, but this idea was
    overturned in favour of std::shared_ptr's and the heap is no longer used anywhere.</p>
<p>Parsing.h is used by the Problem class to load instances from files.</p>
<p>FileCollector.h is used for StatsCollector.h. <b>StatsCollector</b> is very useful to run big
  test suites for many problems with many restarts using different seeds. For usage
  examples see the comments in main.cpp and the evaluateOptimizers() function in
  particular. It outputs .csv files at a specified location and saves the best solutions
  across all the runs for each problem in a mirrored folder structure to the input.</p>
<p>StatsCollector is configured with the default folders of the Solutions and Problems.
  This is not configurable since it would only add a number or arguments to the functions
  that would always be the default in the current setup. It is the only class that has
  such a dependencies to the environment. The locations can be changed easily by changing
  the const members should it be required.</p>

<h2 id="adding_new_opti">Adding new Optimizers</h2>

<p>Things that should not be overlooked if you want to add an optimizer:</p>
<ul>
  <li>do not forget to add the new Optimizer to JS_Lib/include/JS_Lib.h</li>
  <li>you need to implement the virtual functions of optimizer.h</li>
  <li>you probably should not use the Solution class to store the optimizer state, it
    contains way too much redundancy for that</li>
  <li>the search space you use is the most important decision, and using one that only
    contains valid solutions is a major help, otherwise you need to deal with the invalid
    schedules and that takes a lot of effort</li>
  <li>the Solution class has a protected method that is very useful for Representations,
    After the SolutionConstructor has correctly mapped the internal state into the new
    Solution, the CalculateTimings() function can determine all the start and end times.
    </li>
</ul>

<h3 id="conventions">Naming Conventions</h3>
<p>The naming conventions mainly follow the
  <a href="https://google.github.io/styleguide/cppguide.html">Google Style Guide</a> for
  C++. I focused on these rules:</p>
<ul><li>use the wider supported '#ifndef', '#define' guards instead of the '#pragma once'
  guard to prevent duplicate includes</li>
<li>generally prefer long names over abbreviations, especially "custom" abbreviations</li>
<li>types should capitalize each word i.e. 'ObjectName'</li>
<li>all variables are in snake case i.e. 'some_variable'</li>
<li>private class members end with a underscore i.e. 'member_variable_', struct members
  do not have this</li>
<li>functions capitalize the start of all words i.e. 'FunctionName'</li>
<li>getter functions and static functions do not capitalize the first word i.e.
  'getCount'</li></ul>

<h2 id="file_formats">File Formats</h2>

<p>Problems and Solutions are stored and read from text files.
  There are three file formats, two for Problems and one for Solutions.
  The required formats are detailed in the next sections</p>

<h3 id="problem_format">Problem Description</h3>

<p>A Job Shop problem consists of Jobs, a Jobs consists of Tasks, a single Task runs on
  a specific machine and takes a set amount of time.</p>
<p>This project supports two formats, called <b>Standard</b> and <b>Detailed</b>. For
  custom problems the Detailed format is recommended because it allows for more
  consistency checks during parsing.</p>
<p> The Standard format was introduced to be compatible with the format used for the
  public <a href="http://jobshop.jjvh.nl/index.php"> JobShop Instances</a> that were/are
  researched and have known optima.</p>

<h4 id="problem_format_detailed">Detailed Format</h4>

<p>To define a problem in the <b>Detailed</b> specification, follow:</p>
<ul>
    <li>The first line contains two numbers: 'job count' and 'machine count', they
      specify how many jobs and how many machines the problem contains</li>
    <li>Every line afterwards defines exactly one <b>Job</b>. This is done by first
      specifying the number of Task the Job has. Then each Task is specified by a pair
      that defines the 'machine' and 'duration' of the Task. The sequence of the Tasks on
      a line defines the order in which the Tasks need to be processed.</li>
    <li>The comma separator between the pairs can be replaced by any character or omitted
      altogether (commas are recommended for readability).</li>
    <li>Both tabs and spaces are valid white-space characters. The parser also handles
      multiple white-spaces correctly.</li>
</ul>
<p>For the Task definitions to be legal 'machine' has to be in the range [0,machine_count]
  and 'duration' must be >= 0. All values must be integers. The number of Jobs must also
  match the number of Jobs that was specified on the first line.</p>
<p>The file may begin with a comment block. The comment must be a continuous block of
  lines, each starting with '#'.</p>
  <figure style ="max-width:600px">
<p class="example"></p>
<pre># comment lines are possible, no indentation allowed before '#'
3 5
6, 0 8, 3 6, 4 10, 0 3, 1 9, 2 5
4, 3 4, 0 12, 4 16, 3 8
7, 4 19, 2 8, 0 6, 1 10, 3 7, 1 5, 2 9
</pre>
<figcaption><p>JobShopProblems/SmallTestingProblem.txt</p></figcaption>
</figure>

<h4 id="problem_format_standard">Standard Format</h4>

<p>To define a problem in the <b>Standard</b> specification, follow:</p>
<ul>
    <li>The first line contains three numbers: 'job count' and 'machine count' and 'lower
      bound', they specify how many jobs and how many machines the problem contains as
      well as the known optimal lower bound (use <b>-1</b> if the lower bound is unknown)
    </li>
    <li>Every line afterwards defines exactly one <b>Job</b>. This is done by giving a
      pair for each Task. The pair defines the 'machine' and 'duration'
      of the Task. The sequence of the Tasks on a line defines the order in which the
      Tasks need to be processed. Only white-space separators are allowed.</li>
    <li>Both tabs and spaces are valid white-space characters (the files from
      <a href="http://jobshop.jjvh.nl/index.php"> JobShop Instances</a> use tabs).</li>
</ul>
<p>For the Task definitions to be legal 'machine' has to be in the range [0,machine_count]
  and 'duration' must be >= 0. All values must be integers.</p>
<p class="example"></p>
<figure style="max-width: 1300px;">
<pre>
10	10	1234
4	88	8	68	6	94	5	99	1	67	2	89	9	77	7	99	0	86	3	92
5	72	3	50	6	69	4	75	2	94	8	66	0	92	1	82	7	94	9	63
9	83	8	61	0	83	1	65	6	64	5	85	7	78	4	85	2	55	3	77
7	94	2	68	1	61	4	99	3	54	6	75	5	66	0	76	9	63	8	67
3	69	4	88	9	82	8	95	0	99	2	67	6	95	5	68	7	67	1	86
1	99	4	81	5	64	6	66	8	80	2	80	7	69	9	62	3	79	0	88
7	50	1	86	4	97	3	96	0	95	8	97	2	66	5	99	6	52	9	71
4	98	6	73	3	82	2	51	1	71	5	94	7	85	0	62	8	95	9	79
0	94	6	71	3	81	7	85	1	66	2	90	4	76	5	58	8	93	9	97
3	50	0	59	1	82	8	67	7	56	9	96	6	58	4	81	5	59	2	96   
</pre>
<figcaption><p>JobShopProblems/Instances/abz/abz5.txt</p></figcaption>
</figure>
<p>The two relevant differences between the two formats are:
<ul>
  <li>Detailed format: specify number of Tasks (i.e. Pairs) at the start of each line</li>
  <li>Standard format: specify the lower bound of the problem on the first line</li>
</ul>
The remaining white-space and and separator differences are optional.</p>

<h3 id="solution_format">Solution Description</h3>

<p> Solutions have one format. The Python visualizations scripts that create Gantt Charts
  depended on this to parse Solutions, in particular the comma separator is mandatory.</p>
<p>The format to define a problem in the <b>Standard</b> format is as follows:</p>
<ul>
    <li>The first line is the name of the Solution. This is accessible if the Solution is
      loaded in the C++ program and it will be displayed in the Python visualizations.</li>
    <li>The second line contains two numbers: 'job count' and 'machine count', they
      specify how many jobs and how many machines the Solution contains</li>
    <li>Every line afterwards corresponds to a <b>machine</b>. The first number is the
      number of Tasks the Machine processes. After that there is a six-tuple for each Task.
      The tuples are separated by commas and have the format: 'job id' 'task index'
      'machine' 'duration' 'start time' 'end time' </li>
</ul>
<p>The Tasks and Jobs that can be reconstructed from the Solution must match the Problem
  it should solve. This can be checked with the Solution::validateSolution() function for
  arbitrary pairs of Solutions and Problems.</p>
<p>During parsing the first continuous block of lines starting with '#' will be ignored
  as comments.</p>
<p>This is a Solution for the example problem given in the
  <a href="#problem_format_detailed">Detailed Format</a> section.</p>
<p class="example"></p>
<figure style ="max-width:600px">
<pre>
# comments possible
SmallTestingSolutionHandCreated
3 5
4, 0 0 0 8 0 8, 1 1 0 12 8 20, 2 2 0 6 27 33, 0 3 0 3 33 36
3, 2 3 1 10 33 43, 0 4 1 9 43 52, 2 5 1 5 52 57
3, 2 1 2 8 19 27, 0 5 2 5 52 57, 2 6 2 9 57 66
4, 1 0 3 4 0 4, 0 1 3 6 8 14, 2 4 3 7 43 50, 1 3 3 8 50 58
3, 2 0 4 19 0 19, 0 2 4 10 19 29, 1 2 4 16 29 45
</pre>
<figcaption><p>JobShopSolutions/SmallTestingSolution.txt</p></figcaption>
</figure>

<p>Using the <a href="#createGantt">Python Helper Script</a> to create a Gantt Chart for
  this Solution gives:</p>
<figure style="max-width: 800px;">  
  <img src="resources/assets/SmallTestingSolutionVis.png"
    alt="Visualization of Small Testing Solution">
    <figcaption>Visualization of 'SmallTestingSolution.txt'</figcaption>
</figure>
<p>A possible Solution for the abz5 problem shown in the Standard format section is:</p>
<figure style="max-width: 1222px;">
  <img src="resources/assets/abz5SolutionVis.png"
  alt="Visualization of Small Testing Solution">
  <figcaption>Visualization of 'Instances/abz/ShiftingBottleneck_abz5_sol.txt'</figcaption>
</figure>
  
<h2 id="PythonScripts">Python Helper Scripts</h2>

<p>The helper scripts are located in the 'PythonScripts' Folder at the root of the project.
  The two main scripts are "createGanttFromFile.py" and "Google_OR_Tools.py".</p>

<h3 id="createGantt">Create Gantt Visualization</h3>

<p>Creates a visualization of a Solution using
  <a href="https://matplotlib.org/">matplotlib</a>. Example usage:</p>
<figure style ="max-width:500px">
  <pre>$ python createGanttFromFile.py -ri dmu/dmu06.txt</pre>
</figure>
<p>The only parameter is the path to a Solution file. The options allow relative paths to
  be used. Use the '-h' or '-help' flag to get the details about the available option
  flags.</p>
<p>For very large Solutions the chart may struggle to display all the labels in a readable
  manner.</p>

<h3 id="GoogleORTools">Google OR Tools</h3>

<p>This is a simple wrapper for the <a href="https://developers.google.com/optimization">
  Google OR-Tools</a> that can solve JobShop problems with a CP-Solver. It requires the
  installation of the ORTools module (see
  <a href="https://developers.google.com/optimization/install"> OR-Tools Install</a>
  and follow the python guide).</p>
<p>The wrapper enforces a TIMEOUT constraint. Example usage:</p>
<figure style ="max-width:500px">
  <pre>$ python Google_OR_Tools.py -ri dmu/dmu06.txt -t 20 </pre>
</figure>
<p>The script takes two parameters, the path to the Solution file and the timeout. Use
  the '-h' or '-help' flag to get the complete information about the usage.</p>
<p>Additionally there is also the 'runOR_Tools.py' script. It runs 'Google_OR_Tools.py'
  on multiple files.</p>
<p>'runOR_Tools.py' does not take any arguments, instead the code should be edited directly.
  Especially the python version must be set correctly as it currently uses an alias to a
  custom install location.</p>
<p>This script can only parse Problems in the Standard Format (you can convert between
  formats by loading the Problem with JS_Lib and the saving it in the desired format).</p>


</div>
<div class="right-border"></div>
</div>
</body>
</html>
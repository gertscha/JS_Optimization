<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>JS Lib Doc</title>
<link rel="stylesheet" href="resources/styleguide.css">
<link rel="shortcut icon" href="resources/favicon.ico">
<script src="resources/styleguide.js"></script>
</head>
<body onload="initStyleGuide();">

<div class="flex-container">
<div class="left-border"></div>
<div id="content">
<h1>JS Lib Documentation</h1>

<h2 id="Background" class="ignoreLink">Background</h2>

<p>Originally this repository was part of a project for the course "Optimization
  Methods for Engineers" (227-0707-00L) at ETH Zurich.<br> The goal of the project was to
  implement an optimizer for a chosen problem and write a report about the results.</p>

<h3 id="credit" class="ignoreLink">Documentation Credit</h3>

<p>This documentation uses styles and JavaScript taken from the
  <a href="https://github.com/google/styleguide"> Google Style Guides</a>
  (with minor changes).</p>

<!--Create the Table of Contents -->
<div class="horizontal_toc" id="tocDiv"></div>

<h2 id="project_goal">Project Goal</h2>
<p>This repository implements multiple optimizers for the Job Shop scheduling problem.<p>
<p>An instances of the Job Shop scheduling problem consists of N Jobs that need to be
  scheduled on M machines. Each Job in turn consist of Tasks that have
  a processing order. Each of the J<sub>n</sub> Tasks of Job n has their own processing
  time and machine requirement.<br> A machine can only process a single Task at a time and
  processing is not preemptable.</p>
<p>For a rigorous description please consult this
  <a href="resources/assets/ProblemDefinition-ReportExcerpt.pdf">excerpt</a>
  from the report, which gives the mathematical problem definition.</p>
<p>Additionally the repository contains infrastructure to deal with:
  <ul><li>Problems,</li><li>Solutions,</li><li>and Search Space Representations.</li></ul>
  This allows many different optimizers with varying stepping procedures to be implemented
  easily and quickly.</p>

<h2 id="components">Components Overview</h2>

<p>The JS_Optimizer Visual Studio solution contains three projects. They are two libraries
  (JS_Lib and Loguru) and the entry point JS_Optimizer.</p>
<p>The following subsections briefly describe each project.</p>

<h3 id="js_optimizer">JS Optimizer</h3>

<p>This project is designated as the executable for the CMake build and it contains the
  main.cpp file.</p>
<p>The JS_Optimizer project servers as a minimalist wrapper for the JS_Lib functionality
  and enables the creation of actual executables that perform optimization.<br>
  There is no proper user interface, the configuration of the optimizations is done by
  changing the code in the main.cpp file.</p>
<p>Besides the main function it contains the following functions:</p>
<ul>
  <li>a small sanity test function to verify that the project is setup correctly </li>
  <li>a bigger test that exercises all the functionality</li>
  <li>the 'runOptimizer' template function that shows how to create a Problem and
    Optimizer and then run the Optimizer. It also shows how to validate and store the
    Solution. The configuration needs to be done manually.</li>
  <li>the 'evaluateOptimizers' function that uses the StatsCollector utility class to run
    and log an optimizer on many problems in bulk.</li>
</ul>
<p>These functions and the commented lines in the main function provide some usage
  examples.</p>
<p>Some global variables that define the paths are also automatically setup with the
  CMake build.</p>

<h3 id="optimizer">JS Lib</h3>

<p>This project is the core functionality. All the optimization code is completely
  contained inside the JS_Lib project.<br> The code in JS_Lib can be grouped like this:
  problem_base, optimizer_base, optimizers and utility.</p>

<figure style ="max-width:800px">
  <img src="resources/assets/JS_Lib_UML.svg" alt="UML Diagram of JS_Lib">
  <figcaption>For clarity reasons not all associations are depicted, the most obvious
    omissions are the links from problem_base to the optimizers, additionally each
    representation also subclasses the Solution class in order to provide a
    constructor for Solutions</figcaption>
</figure>

<p>The 'problem_base' enables the creation, saving and loading of Problem instances. It
  also defines the general Solution object that all optimizers ultimately generate. The
  Solution class also offers a validation utility.</p>
<p>The 'optimizer_base' code defines 'Optimizer.h', a base class for all optimizers.
  It also defines multiple possible representations on which an optimizer can operate.<br>
  The representations provide initialisation and basic manipulation of the representation
  as well as the creation of Solutions from the internal state.</p>
<p>Optimizers choose a representation and then define the initialisation, iteration and
  termination functions for the optimization process of the optimizer. Currently there are
  four different optimizers implemented.</p>
<p>Both new representations and optimizers can be added.<br>
  All optimizers should subclass/extend the Optimizer class defined in Optimizer.h.
  However using a representation is not required.</p>
<p>For more details see the <a href="#structure">JS Lib</a> section below.</p>

<h3 id="loguru">Loguru</h3>

<p>The logging needs of the project are covered with "Loguru" by emilk.
  See his <a href="https://github.com/emilk/loguru"> Github repository</a>.</p>
<p>Version 2.1.0 cloned in April 2023 is included/setup in this repository. Refer to it's 
  <a href="loguru_docs/index.html">documentation</a> and the README in the Loguru folder
  for usage details.</p>

<h3 id="dependencies">Dependencies</h3>

<p>The project uses CMake to setup the Visual Studio solution, hence it requires both
  CMake and Visual Studio.</p>
<p>There are a couple optional helper scripts that require a Python installation
  (see <a href="#PythonScripts">Python Helper Scripts</a>).<br> Some of the scripts use
  <a href="https://developers.google.com/optimization">Google OR-Tools</a>.
  They require the installation of the 'ortools' package, see the
  <a href="https://developers.google.com/optimization/install/python">Installation Guide</a>
  from the Google OR-Tools website.</p>

<h2 id="js_lib">JS Lib</h2>

<p>The following sections will cover the components in more detail. But this documentation
  does not aim to provide a User Manual for the code. The usage of the existing code
  should be evident from the names of the objects functions and arguments.</p>
<p>Instead the conceptual ideas behind the components will be explained. Additionally
  what functionality each component offers will be explained.</p>

<h3 id="js_problem">Problems</h3>

<p>Problem objects can be created from text files. The constructor requires the path and
  name of a file that contains a valid problem description (see
  <a href="#problem_format">Problem Description</a> for the required format). A problem
  object provides a number of getter functions to inspect it, but it is immutable.</p>
<p>Each Problem also has a Problem::Bounds instance associated with it. The Bounds object
  provides some absolute lower bounds on the completion time of the Problem.</p>
<p>The Problem class offers:</p>
<ul>
  <li>Loading of Problem instances from files.</li>
  <li>Creation of Problem instances from a given Solution.</li>
  <li>Saving of Problem instances to a file (with a format selection).</li>
  <li>Accessor methods to inspect a Problem.</li>
  <li>Basic timing bounds information about the Problem with the Problem::Bounds
    class.</li>
</ul>
<p>See Problem.h for the details.</p>

<h3 id="js_solution">Solutions</h3>

<p>Solution objects usually get created by Optimizers. Usually the Representation the 
  Optimizer uses should implement a nested class that extends Solution and
  provides a constructor for Solutions.</p>
<p>Solutions are immutable. Typically they get shared between the user code and
  the Optimizer itself. This is done safely with std::shared_ptr.</p>
<p>Solutions have their own file format (see
  <a href="#solution_format">Solution Description</a>).
  This format contains quite a lot of redundancy, this is used for faster and more
  thorough integrity checking. It prevents the validation from inferring incorrect
  parameters.</p>
<p>Since the Solution class contains redundancy and is immutable it should not be used to
  store the internal solution state of optimizers. Instead a SolutionConstructor that
  subclasses Solution should be implemented. SolutionConstructor then converts the
  internal solution state to a Solution. This should be provided by the Search Space
  Representations.</p>
<p>The Solution class offers:</p>
<ul>
  <li>Loading of Solutions from files.</li>
  <li>Saving of Solutions to files (and by extension Visualization with the Python
    scripts).</li>
  <li>Accessor methods to inspect basic properties like the makespan, task count, etc.</li>
  <li>The Solution validation to check if a Solution is valid with respect to
    a given Problem instance.</li>
</ul>
<p>See Solution.h for the details.</p>

<h3 id="js_optimizer_base">Optimizer Base</h3>

<p>Optimizer_base contains Optimizer.h which is the base class for all optimizers. Having
  a base class allows easy polymorphism and gives all optimizers a common interface.</p>
<p>The other classes in optimizer_base implement Search Space Representations. They
  subclass the Optimizer base class.</p>

<h4 id="js_optimizer_h">Optimizer.h</h4>

<p> Optimizer.h defines some pure virtual functions that need to be implemented.
  They are:<ul>
    <li><pre style="max-width: 150px; margin-left: 0;">void Initialize()</pre>
      <p style="text-indent: 25px;">initializes an optimization run</p></li>
    <li><pre style="max-width: 125px;margin-left: 0;">void Iterate()</pre>
      <p style="text-indent: 25px;">performs an optimization iteration</p></li>
    <li><pre style="max-width: 255px;margin-left: 0;">bool CheckTermination() const</pre>
      <p style="text-indent: 25px;">returns true if the termination criteria are
        reached</p></li>
    <li><pre style="max-width:380px;margin-left:0;"
      >std::shared_ptr&ltSolution&gt getBestSolution()</pre>
      <p style="text-indent: 25px;">get current best solution, sharing ownership</p></li>
    <li><pre style="max-width: 320px;margin-left: 0;"
      >std::string getOptimizerName() const</pre>
      <p style="text-indent: 25px;">allows easy identification if used with polymorphism
        </p></li></ul>
  The Representations do not implement these as they are intended to function as an
  intermediate that provides common functionality for a specific optimization structure.
</p>
<p>Optimizer.h also contains a 'Run' function with a default implementation that can be
  overridden.</p>
<p>Typically an optimizer subclasses an Representation. It provides implementations for
  the functions mentioned above and uses the utilities the Representation provides.</p>
<p>The Representations that are provided in JS_Lib are described in their own sections
  below.</p>
<p>Optimizer Base also defines the <b>Termination Criteria</b> struct with the three
  different criteria: total iterations, restart count and a percentage relative to the
  lower bound. The 'CheckTermination()' should use this. Since the concept of an iteration
  may vary for different optimizers there is no default implementation for it.</p>
  
<h4 id="js_optimizer_machine_order_rep">Machine Order representation</h4>

<p>This Search Space Representation is straight forward. All Tasks are grouped per machine
  and placed in multisets. Then Tasks are pulled from a set to build the precedence order
  for the machine the set corresponds to.</p>
<figure style ="max-width:500px">
  <img src="resources/assets/Machine_Seq.svg"
    alt="Visualization of Machine Order Rep">
    <figcaption>Machine Sequences: underlying search structure</figcaption>
</figure>
<p>The simple concept allows for a relatively simple implementation. All Tasks get
  assigned a unique id. This mapping is stored in the 'task_map_' member.</p>
<p>Each Machine has an instance of the MachineClique class which provides some getters
  and the current schedule for the machine. The schedule can be retrieved with the
  'getMachineOrder()'. It's contents should remain the same, only the order may be
  modified, else the Solution will be invalid with respect to the Problem.</p>
<p>The schedule uses indirection to prevent a Task from Job x getting scheduled
  before another Task from Job x on the Machine that has a lower index. Meaning that the
  Set of Tasks is actually represented as a multiset of Job ids. The clique has an ordered
  list of task ids for each job. By tracking how far along the list each Job is, it is
  guaranteed that each Machine has an internal precedence order that is valid.</p>
<p>This only covers half the conflicts that may occur. The solution may still be unfeasible
  due to deadlocks across multiple machines. This is the major downside to this
  representation. It is very difficult to find and resolve these conflicts in this
  representation. The solution constructor will return uninitialized solutions should the
  current state be invalid. In that case the Solution will have a 'makespan_' of -1 and the
  'initialized_' bool will be false.</p>
<p>The representation builds the machine cliques and mappings. The initial state is the
  sequential Solution obtain by scheduling the Jobs in ascending order. It also provides
  a Solution Constructor that builds the Solution from the current state the cliques
  contain.</p>
<p>The specific optimizer only needs to decide how elements are reordered in the cliques.</p>

<h4 id="js_optimizer_global_order_rep">Global Order representation</h4>

<p>Like the name suggests, this Search Space Representation uses a global ordering. The
  core of the representation is a list that contains each Job Task-count times. This
  indirection functions similarly to the Machine Order and it is used to prevent deadlocks
  from occurring.</p>
<figure style ="max-width:600px">
  <img src="resources/assets/Total_Order.svg" 
    alt="Visualization of Total Order Rep">
    <figcaption>Total Order: underlying search structure</figcaption>
</figure>
<p>The Index Lookup informs us how far along the list in the Lookup Table we are. This
  ensures each Job is conflict free. The global order intrinsically prevents conflicts
  across different Machines.</p>
<p>For these reasons the Global Task Order representation is only able to represent valid
  solutions. It can also still represent all possible solutions. The trade off comes in a
  different form. This representation increases the size of the search space
  significantly. The reason being that the number of permutations of the Total Order list
  is significantly larger than the combined number of permutations of all the individual
  Machines.</p>
<p>In practice this is an acceptable trade off. The two main reasons being:
  <ul><li>the original search space is already too large to be searched by brute force</li>
  <li>the number of invalid solutions is far larger than the number of valid solutions</li>
</ul>Ultimately the benefit of the restriction to valid solutions outweighs the downside of
the larger search space.</p>
<p>The Representation implements a constructor that creates an initial Total Order,
  representing the sequential solution. It also provides the SolutionConstructor that
  builds the Solution corresponding to the current Total Order.</p>
<p>The representation does not provide any utilities to provide information about bottlenecks
  in the schedule. An optimizer requiring such information has to implement this themselves.
  This is not provided for efficiency reasons, as the optimizer needs to decide very
  specifically what information it requires. Since the Representation loses a lot of
  information and it is expensive to recompute it.</p>

<h4 id="js_optimizer_graph_rep">Graph representation</h4>

<p>The Disjunctive Graph Representation is well known in literature. It is rather complex
  but makes a lot of information easily accessible. It also allows targeted manipulation
  of the current schedule.</p>
<p>Each vertex in the graph represents a Task. There are two kinds of edges. The
  R<sub>p</sub> relation contains edges that capture the immutable constraints of the
  problem instance (i.e. the Task processing order). The machine cliques are the
  mutable edges that an optimizer can change. They represent the actual schedule.</p>
<p>This is the initial state of the representation:</p>
<figure style="max-width:500px">
  <img src="resources/assets/Graph_Rep.svg"
    alt="Visualization of Graph Rep components">
    <figcaption>Disjunctive Graph: underlying search structure</figcaption>
</figure>
<p>Each group of nodes that is connected by a complete graph of bidirectional edges
  represents Tasks that need to be processed on the same Machine. To create a schedule
  all the bidirectional edges need to be directed. The schedule is valid if and only if
  the complete graph containing both the Machine Clique edges and R<sub>p</sub> edges is
  acyclic.</p>
<p>GraphRep initializes all the immutable edges in the graph but leaves it up to the
  optimizer to insert the mutable edges (usually done with DacExtender). The cliques_
  member contains a list for each Machine that holds all the vertex ids that are to be
  scheduled on it.</p>

<p>The GraphRep.h class provides a number of helpers to achieve this. The main ones are:</p>
<ul><li>PathsInfo</li>
  <li>DacExtender</li>
  <li>Graph helpers</li>
<li>Solution Constructor</li></ul>
<p>All PathsInfo instances are tightly coupled with a single GraphRep instance. PathsInfo
  calculates the Critical Path of the current graph/schedule. It does this with the
  <a href="https://en.wikipedia.org/wiki/Critical_path_method">critical path method</a>
  (CPM). A notable by-product of CPM is the current makespan of the graph. The main output
  of the CPM is the list of vertices on the critical path, but the concrete timings are
  also available.</p>
<p>DacExtender is a dynamic topological sorter. It takes an acyclic graph as input and then
  provides the 'InsertEdge()' function which takes two vertices as arguments and returns a
  directed edge that maintains the acyclic property of the graph. DacExtender performs
  deterministic insertion of new edges. But by randomizing the insertion order, the result
  can be randomized. This enables deterministic time random generation of initial DAC's
  that an optimizer can iterate on (i.e. random restarts).</p>
<p>There are a few helper functions to facilitate the changing of the internal graph, see
  GraphRep.h. They include a reachable and a cycle checker.</p>
<p>The SolutionConstructor simply creates a Solution from the internal state.</p>
<p>It also has mappings from vertices to Steps and a separate mapping to the duration of
  the Step directly to avoid a double lookup.</p>

<h5 id="js_graphrep_subclassing">Sub-classing GraphRep</h5>

<p><b style="font-size: 11pt;">NOTE:</b></p>
<ul>
<li>If an optimizer <b>manually</b> changes the graph, it must set the 'modified_flag'
  bool member. If this is not done correctly PathsInfo will perform <b>no-ops</b> when
  update is called.</li>
<li>Two additional special vertices are introduced when a problem is loaded. A source
  (id:0) and a sink vertex (id:vertex_count_-1).</li>
<li>GraphRep uses unified successor and predecessor lists. Positive values encode
  successors and negative values predecessors. Additionally the immutable R<sub>p</sub>
  edges are separated from the mutable Machine Clique edges. This is done by adding an
  offset of vertex_count_ to the Machine Clique edges before any other operations.
  Combined this means for each vertex all neighbours can be found by iterating over
  graph_[vertex_id] and they can easily be filtered for predecessor, successor and
  mutability.</li>
</ul>

<h3 id="js_optimizers">Optimizers</h3>

<p>All Optimizer's subclass one of the optimizer_base classes. The different Representation
  classes implement some common functionality that a given search space representation
  may need. See their header files in JS_Lib/optimizer_base/ or the
  <a href="#js_optimizer_base">Optimizer Base</a> section of the documentation.</p>
<p>The optimizers themselves are not meant to be sub-classed.</p>
<p>All optimizers should subclass <a href="#js_optimizer_h">Optimizer.h</a>. Either
  directly or indirectly through a representation. And consequently they must implement
  the pure virtual functions Optimizer.h defines (<a href="#js_optimizer_h">see here</a>
  ).</p>
<p>The following sections will briefly describe the Optimizers that are already
  implemented.</p>

<h4 id="RandomSearchOpti">RandomSearch Optimizer</h4>

<p>This is a classic 'Random search' optimizer on the
  <a href="#js_optimizer_global_order_rep">Total Order Representation</a>.</p>
<p>It simply randomly shuffles the list containing the total order.</p>

<h4 id="RandomSearchMachOpti">RandomSearchMachine Optimizer</h4>

<p>This is a classic 'Random search' optimizer on the
  <a href="#js_optimizer_machine_order_rep">Machine Order Representation</a>.</p>
<p>It randomly shuffles the list with the ordering of each machine.</p>

<h4 id="RandomSwapOpti">RandomSwap Optimizer</h4>

<p>This is a 'Simulated Annealing' optimizer on the
    <a href="#js_optimizer_global_order_rep">Total Order Representation</a>.</p>
<p>It has all the typical components of a Simulated Annealing optimizer:
  <ul><li>a temperature that starts high and decreases with time</li>
  <li>making more changes per iteration if the temperature is higher</li>
  <li>a chance to accept worse Solutions that decreases as the Temperature decreases</li>
  <li>early random restarts if no progress is made for a number of iterations</li></ul>
</p>
<p>This optimizer uses a simple neighbourhood definition. Two solutions are direct
  neighbours if the schedule of one can be transformed into the other by performing a
  single swap of two consecutive elements in the total order list.</p>

<h4 id="ShftingBottleneckOpti">ShiftingBottleneck Optimizer</h4>

<p>This is a 'Simulated Annealing' optimizer on the
  <a href="#js_optimizer_graph_rep">Graph Representation</a>.</p>
<p>It has all the typical components of a Simulated Annealing optimizer:
  <ul><li>a temperature that starts high and decreases with time</li>
  <li>making more changes per iteration if the temperature is higher</li>
  <li>a chance to accept worse Solutions that decreases as the Temperature decreases</li>
  <li>early random restarts if no progress is made for a number of iterations</li></ul>
</p>
<p>This optimizer uses a number of heuristics to preselect swaps to alter the critical
  path of the graph. The choice of which swaps to perform is randomized. The number of swaps
  is determined by the temperature. See this
  <a href="resources/assets/EdgeSelectionHeuristics-ReportExcerpt.pdf">excerpt</a>
  of the report for a more detailed description of the heuristics.</p>

<h4 id="OptiPerformance">Performance Overview</h4>

<p>ShiftingBottleneck is the best among the implemented optimizers. It is also by far the
  slowest. It can find decent solutions with 2000 iterations. With the release build this
  should not take more than a couple minutes on decent hardware, even for the largest
  problems in the Instance folder. But it tends to bottleneck itself due to the implemented
  heuristics stalling in local optima. Because of this increasing the iteration count is
  usually not beneficial. Instead using more seeds and doing more runs with them is the
  better option to find better solutions.</p>
<p>RandomSwap and RandomSearch are essentially equivalent. They use the same Representation
  and although RandomSwap uses a different approach it relies on a neighbourhood definition
  that does not contain useful information. Consequently its behaviour is equivalent to
  the random shuffling RandomSearch does. These two Optimizers are very fast and given
  enough time could find the optimum. However the search space is many times too large for
  even a supercomputer to evaluate a decent percentage of the search space. For a low
  number of iterations, say under 10'000, ShiftingBottleneck should outperform these two
  consistently.</p>
<p>RandomSearchMachine is a useless optimizer. It fails to find valid solutions at all,
  unless very small problems are used. The reason likely being that the cross machine
  conflicts are far too common, making a vast majority of the schedules invalid (Or
  there is a major bug in the implementation).</p>

<h3 id="js_utility">Utility</h3>

<p>Most of the utility code is not helpful when implementing Optimizers. But a couple
  functions might be nice, they are in:</p>
<ul><li>Utility.h</li><li>Heap.h</li></ul>
<p>Utility.h has remove_at() and randomPullUniqueFromRange(), which may be useful to
  access a container like a vector. The other functions are unlikely to be useful when
  implementing optimizers.</p>
  <p>The Heap class is a wrapper around the std::make_heap and friends of &ltalgorithm&gt
    and can be both a Max or a Min heap based on the comparator.
    The original intent was to store multiple solutions in a max heap, but this idea was
    overturned in favour of std::shared_ptr's and the heap is no longer used anywhere.</p>
<p>Parsing.h is used by the Problem class to load instances from files.</p>
<p>FileCollector.h is used for StatsCollector.h. <b>StatsCollector</b> is very useful to run big
  test suites for many problems with many restarts using different seeds. For usage
  examples see the comments in main.cpp and the evaluateOptimizers() function in
  particular. It outputs .csv files at a specified location and saves the best solutions
  across all the runs for each problem in a mirrored folder structure to the input.</p>

<h2 id="adding_new_opti">Adding new Optimizers</h2>

<p>Things that should not be overlooked if you want to add an optimizer:</p>
<ul>
  <li>do not forget to add the new Optimizer to JS_Lib/include/JS_Lib.h</li>
  <li>you need to implement the virtual functions of optimizer.h</li>
  <li>you probably should not use the Solution class to store the optimizer state, it
    contains way too much redundancy for that</li>
  <li>the search space you use is the most important decision, and using one that only
    contains valid solutions is a major help, otherwise you need to deal with the invalid
    schedules and that takes a lot of effort</li>
</ul>


<h2 id="file_formats">File Formats</h2>

<p>Problems and Solutions are stored and read from text files.
  There are three file formats, two for Problems and one for Solutions.
  The required formats are detailed in the next sections</p>

<h3 id="problem_format">Problem Description</h3>

<p>A Job Shop problem consists of Jobs, a Jobs consists of Tasks, a single Task runs on
  a specific machine and takes a set amount of time.</p>
<p>This project supports two formats, called <b>Standard</b> and <b>Detailed</b>. For
  custom problems the Detailed format is recommended because it allows for more
  consistency checks during parsing.</p>
<p> The Standard format was introduced to be compatible with the format used for the
  public <a href="http://jobshop.jjvh.nl/index.php"> JobShop Instances</a> that were/are
  researched and have known optima.</p>

<h4 id="problem_format_detailed">Detailed Format</h4>

<p>To define a problem in the <b>Detailed</b> specification, follow:</p>
<ul>
    <li>The first line contains two numbers: 'job count' and 'machine count', they
      specify how many jobs and how many machines the problem contains</li>
    <li>Every line afterwards defines exactly one <b>Job</b>. This is done by first
      specifying the number of Task the Job has. Then each Task is specified by a pair
      that defines the 'machine' and 'duration' of the Task. The sequence of the Tasks on
      a line defines the order in which the Tasks need to be processed.</li>
    <li>The comma separator between the pairs can be replaced by any character or omitted
      altogether (commas are recommended for readability).</li>
    <li>Both tabs and spaces are valid white-space characters. The parser also handles
      multiple white-spaces correctly.</li>
</ul>
<p>For the Task definitions to be legal 'machine' has to be in the range [0,machine_count]
  and 'duration' must be >= 0. All values must be integers. The number of Jobs must also
  match the number of Jobs that was specified on the first line.</p>
<p>The file may begin with a comment block. The comment must be a continuous block of
  lines, each starting with '#'.</p>
  <figure style ="max-width:600px">
<p class="example"></p>
<pre># comment lines are possible, no indentation allowed before '#'
3 5
6, 0 8, 3 6, 4 10, 0 3, 1 9, 2 5
4, 3 4, 0 12, 4 16, 3 8
7, 4 19, 2 8, 0 6, 1 10, 3 7, 1 5, 2 9
</pre>
<figcaption><p>JobShopProblems/SmallTestingProblem.txt</p></figcaption>
</figure>

<h4 id="problem_format_standard">Standard Format</h4>

<p>To define a problem in the <b>Standard</b> specification, follow:</p>
<ul>
    <li>The first line contains three numbers: 'job count' and 'machine count' and 'lower
      bound', they specify how many jobs and how many machines the problem contains as
      well as the known optimal lower bound (use <b>-1</b> if the lower bound is unknown)
    </li>
    <li>Every line afterwards defines exactly one <b>Job</b>. This is done by giving a
      pair for each Task. The pair defines the 'machine' and 'duration'
      of the Task. The sequence of the Tasks on a line defines the order in which the
      Tasks need to be processed. Only white-space separators are allowed.</li>
    <li>Both tabs and spaces are valid white-space characters (the files from
      <a href="http://jobshop.jjvh.nl/index.php"> JobShop Instances</a> use tabs).</li>
</ul>
<p>For the Task definitions to be legal 'machine' has to be in the range [0,machine_count]
  and 'duration' must be >= 0. All values must be integers.</p>
<p class="example"></p>
<figure style="max-width: 1300px;">
<pre>
10	10	1234
4	88	8	68	6	94	5	99	1	67	2	89	9	77	7	99	0	86	3	92
5	72	3	50	6	69	4	75	2	94	8	66	0	92	1	82	7	94	9	63
9	83	8	61	0	83	1	65	6	64	5	85	7	78	4	85	2	55	3	77
7	94	2	68	1	61	4	99	3	54	6	75	5	66	0	76	9	63	8	67
3	69	4	88	9	82	8	95	0	99	2	67	6	95	5	68	7	67	1	86
1	99	4	81	5	64	6	66	8	80	2	80	7	69	9	62	3	79	0	88
7	50	1	86	4	97	3	96	0	95	8	97	2	66	5	99	6	52	9	71
4	98	6	73	3	82	2	51	1	71	5	94	7	85	0	62	8	95	9	79
0	94	6	71	3	81	7	85	1	66	2	90	4	76	5	58	8	93	9	97
3	50	0	59	1	82	8	67	7	56	9	96	6	58	4	81	5	59	2	96   
</pre>
<figcaption><p>JobShopProblems/Instances/abz/abz5.txt</p></figcaption>
</figure>
<p>The two relevant differences between the two formats are:
<ul>
  <li>Detailed format: specify number of Tasks (i.e. Pairs) at the start of each line</li>
  <li>Standard format: specify the lower bound of the problem on the first line</li>
</ul>
The remaining white-space and and separator differences are optional.</p>

<h3 id="solution_format">Solution Description</h3>

<p> Solutions have one format. The Python visualizations scripts that create Gantt Charts
  depended on this to parse Solutions, in particular the comma separator is mandatory.</p>
<p>The format to define a problem in the <b>Standard</b> format is as follows:</p>
<ul>
    <li>The first line is the name of the Solution. This is accessible if the Solution is
      loaded in the C++ program and it will be displayed in the Python visualizations.</li>
    <li>The second line contains two numbers: 'job count' and 'machine count', they
      specify how many jobs and how many machines the Solution contains</li>
    <li>Every line afterwards corresponds to a <b>machine</b>. The first number is the
      number of Tasks the Machine processes. After that there is a six-tuple for each Task.
      The tuples are separated by commas and have the format: 'job id' 'task index'
      'machine' 'duration' 'start time' 'end time' </li>
</ul>
<p>The Tasks and Jobs that can be reconstructed from the Solution must match the Problem
  it should solve. This can be checked with the Solution::validateSolution() function for
  arbitrary pairs of Solutions and Problems.</p>
<p>During parsing the first continuous block of lines starting with '#' will be ignored
  as comments.</p>
<p>This is a Solution for the example problem given in the
  <a href="#problem_format_detailed">Detailed Format</a> section.</p>
<p class="example"></p>
<figure style ="max-width:600px">
<pre>
# comments possible
SmallTestingSolutionHandCreated
3 5
4, 0 0 0 8 0 8, 1 1 0 12 8 20, 2 2 0 6 27 33, 0 3 0 3 33 36
3, 2 3 1 10 33 43, 0 4 1 9 43 52, 2 5 1 5 52 57
3, 2 1 2 8 19 27, 0 5 2 5 52 57, 2 6 2 9 57 66
4, 1 0 3 4 0 4, 0 1 3 6 8 14, 2 4 3 7 43 50, 1 3 3 8 50 58
3, 2 0 4 19 0 19, 0 2 4 10 19 29, 1 2 4 16 29 45
</pre>
<figcaption><p>JobShopSolutions/SmallTestingSolution.txt</p></figcaption>
</figure>

<p>Using the <a href="#createGantt">Python Helper Script</a> to create a Gantt Chart for
  this Solution gives:</p>
<figure style="max-width: 800px;">  
  <img src="resources/assets/SmallTestingSolutionVis.png"
    alt="Visualization of Small Testing Solution">
    <figcaption>Visualization of 'SmallTestingSolution.txt'</figcaption>
</figure>
<p>A possible Solution for the abz5 problem shown in the Standard format section is:</p>
<figure style="max-width: 1222px;">
  <img src="resources/assets/abz5SolutionVis.png"
  alt="Visualization of Small Testing Solution">
  <figcaption>Visualization of 'Instances/abz/ShiftingBottleneck_abz5_sol.txt'</figcaption>
</figure>
  
<h2 id="PythonScripts">Python Helper Scripts</h2>

<p>The helper scripts are located in the 'PythonScripts' Folder at the root of the project.
  The two main scripts are "createGanttFromFile.py" and "Google_OR_Tools.py".</p>

<h3 id="createGantt">Create Gantt Visualization</h3>

<p>Creates a visualization of a Solution using
  <a href="https://matplotlib.org/">matplotlib</a>. Example usage:</p>
<figure style ="max-width:500px">
  <pre>$ python createGanttFromFile.py -ri dmu/dmu06.txt</pre>
</figure>
<p>Use the '-h' or '-help' flag to get the complete information about the usage.</p>
<p>For very large Solutions the chart may struggle to display all the labels in a readable
  manner.</p>

<h3 id="GoogleORTools">Google OR Tools</h3>

<p>This is a simple wrapper for the <a href="https://developers.google.com/optimization">
  Google OR-Tools</a> that can solve JobShop problems with a CP-Solver. It requires the
  installation of the ORTools module (see
  <a href="https://developers.google.com/optimization/install"> OR-Tools Install</a>
  and follow the python guide).</p>
<p>The wrapper enforces a TIMEOUT constraint. Example usage:</p>
<figure style ="max-width:500px">
  <pre>$ python Google_OR_Tools.py -ri dmu/dmu06.txt -t 20 </pre>
</figure>
<p>Use the '-h' or '-help' flag to get the complete information about the usage.</p>
<p>Additionally there is also the 'runOR_Tools.py' script. It runs 'Google_OR_Tools.py'
  on multiple files.</p>
<p>'runOR_Tools.py' does not take any arguments, instead the code should be edited directly.
  Especially the python version must be set correctly as it currently uses an alias to a
  custom install location.</p>
<p>This script can only parse Problems in the Standard Format (you can convert between
  formats by loading the Problem with JS_Lib and the saving it in the desired format).</p>


</div>
<div class="right-border"></div>
</div>
</body>
</html>